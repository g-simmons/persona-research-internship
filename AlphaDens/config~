config0 := proc(xx::Array(datatype=float[8]),B1::Array(datatype=float[8]),R::float[8],beta::float[8],xx1::Array(datatype=float[8]),n::integer[4],m::integer[4],N1::integer[4])
    H := Float(infinity);
    m1 := n*m;
    for t from 1 to N1 do
        for j from 1 to m1 do
            xx1[j] := B1[t,j];
        end do;
        for j from 1 to m1 do
            xx1[j] := xx1[j]+xx[j];
        end do;
        x0 := 0.0;
        y0 := 0.0;
        for j from 1 to n do
            x0 := x0+xx1[2*j-1];
            y0 := y0+xx1[2*j];
        end do;
        for j from 1 to n do
            xx1[2*j-1] := xx1[2*j-1]-x0/n;
            xx1[2*j] := xx1[2*j]-y0/n;
        end do;
        H0 := 0.0;
        for i from 1 to n do
            H0 := H0+xx1[2*i-1]^2+xx1[2*i]^2;
        end do;
        H0 := H0/R/R;
        H1 := 0.0;
        for i from 1 to n do
            for j from i+1 to n do
                r1 := xx1[2*i-1]-xx1[2*j-1];
                r2 := xx1[2*i]-xx1[2*j];
                r := r1*r1+r2*r2;
                H1 := H1+1/r^6-1/r^3;
            end do;
        end do;
        H1 := H1*4.0;
        H1 := H1+H0;
        r := (rand() mod 10000000)/evalf(10000000);
        if(r<=exp(-beta*(H1-H))) then
            for j from 1 to m1 do
                xx[j] := xx1[j];
            end do;
            H := H1;
        end if;
    end do;
end proc;

config0 := Compiler:-Compile(config0);

config := proc(n)
    md := module()
    export xx,xx1,h,n,m,m1,B1,beta,R,H,getstate,setstate,initstate,walk,init,sample,draw;
    local dyn,ModulePrint;
        ModulePrint::static := proc()
            return nprintf("configuration space of %d points in R^%d",n,m);
        end proc;
        getstate::static := proc()
            return xx;
        end proc;
        setstate::static := proc(yy)
            setvec(xx,yy);
        end proc;
        initstate::static := proc()
            Sample(Normal(0,R),xx);
            x0 := 0.0;
            y0 := 0.0;
            for j from 1 to n do
                x0 := x0+xx[2*j-1];
                y0 := y0+xx[2*j];
            end do;
            for j from 1 to n do
                xx[2*j-1] := xx[2*j-1]-x0/n;
                xx[2*j] := xx[2*j]-y0/n;
            end do;
        end proc;
        walk::static := proc(N1)
            if(dyn:-allocif(N1)) then
                B1 := dyn:-getelts();
            end if;
            Sample(Normal(0,h),B1);
            config0(xx,B1,R,beta,xx1,n,m,N1);
            return xx;
        end proc;
        H::static := proc(yy:=xx)
            H0 := add(yy[i]^2,i=1..m1)/R^2;
            ans := 0;
            for i from 1 to n do
                for j from i+1 to n do
                    r := (yy[2*i-1]-yy[2*j-1])^2+(yy[2*i]-yy[2*j])^2;
                    ans := ans+1/r^6-1/r^3;
                end do;
            end do;
            return H0+4.0*ans;
        end proc;
        sample::static := proc(M,nsteps)
            if(type(M,'numeric')) then
                M1 := M;
                ans := allocla[float[8]]([M,m1]);
            else
                ans := args[1];
                M1 := Dimension(ans)[1];
            end if;
            for t from 1 to M1 do
                initstate();
                walk(nsteps);
                setrow1(ans,t,xx,m1);
            end do;
            return ans;
        end proc;
        draw::static := proc(yy:=xx)
            return drawconf(yy,true);
        end proc;
        init::static := proc()
            n := args;
            m := 2;
            m1 := n*m;
            xx,xx1 := allocla[float[8]](m1,m1);
            dyn := dynla(float[8](m1));
            B1 := dyn:-getelts();
            beta := 2.0;
            h := .3;
            R := 3.0;
        end proc;
    end module;
    md:-init(n);
    return md;
end proc;

sampconf := proc(N,nsteps,beta,R:=3)
local r,xx;
    H0 := r->4*(1/r^6-1/r^3);
    H := add(add(H0((cat(x,i)-cat(x,j))^2+(cat(y,i)-cat(y,j))^2),j=i+1..3),i=1..3);
    H := H+add(cat(x,i)^2+cat(y,i)^2,i=1..3)/2/R^2;
    print(H);
    vars := [x1,y1,x2,y2,x3,y3];
    params := [];
    met := physwalk(H,vars,params);
    met:-beta := beta;
    B := matf(N,6);
    Sample(Normal(0,R),B);
    ans := rowmap(xx->met:-getwalk(xx,nsteps),B);
    ans := rowmap(centconf,ans);
    return ans;
end proc;

normconf := proc(V)
    typ := op(1,procname);
    if(typ='cent') then
        return centconf[op(2..nops(procname),procname)](V);
    elif(typ='rot') then
        return normconf1(V);
    elif(typ='rotnorm') then
        return normconf2(V);
    elif(typ='hopf') then
        return hopfmap(V);
    end if;
end proc;

centconf := proc(V)
    p1,p2,p3 := [V[1],V[2]],[V[3],V[4]],[V[5],V[6]];
    if(type(procname,indexed) and nops(procname)=1) then
        i := op(procname);
        p0 := [p1,p2,p3][i];
    else
        p0 := (p1+p2+p3)/3;
    end if;
    return [op(p1-p0),op(p2-p0),op(p3-p0)];
end proc;

normconf1 := proc(V)
    p1,p2,p3 := [V[1],V[2]],[V[3],V[4]],[V[5],V[6]];
    p2 := p2-p1;
    p3 := p3-p1;
    p1 := p1-p1;
    r := sqrt(p2[1]^2+p2[2]^2);
    c,s := op(p2/r);
    p2 := [c*p2[1]+s*p2[2],-s*p2[1]+c*p2[2]];
    p3 := [c*p3[1]+s*p3[2],-s*p3[1]+c*p3[2]];
    return [op(p1),op(p2),op(p3)];
end proc;

normconf2 := proc(V)
    vv := normconf1(V);
    p1,p2,p3 := [vv[1],vv[2]],[vv[3],vv[4]],[vv[5],vv[6]];
    r := sqrt(p2[1]^2+p2[2]^2);
    return [op(p3),r];
end proc;

confkde0 := proc(B)
uses combinat;
    N,m := Dimension(B);
    if(m<>6) then
        error;
    end if;
    N1 := floor(N/6);
    for i1 from 1 to N1 do
        k1 := 6*(i1-1)+1;
        sig := [1,2,3];
        for i2 from 1 to 5 do
            k2 := k1+i2;
            sig := nextperm(sig);
            for j from 1 to 3 do
                B[k2,2*j-1] := B[k1,2*sig[j]-1];
                B[k2,2*j] := B[k1,2*sig[j]];
            end do;
        end do;
    end do;
    for i from 6*N1+1 to N do
        for j from 1 to 6 do
            B[i,j] := 0.0;
        end do;
    end do;
end proc;

#replaces f by a symmetrized one with the S3 action
confkde := proc(f)
    argl := [f];
    md := module()
    option object;
    export f,N,m,numpoints,getdim,sample;
        f := op(argl);
        numpoints::static := f::numpoints;
        getdim::static := f:-getdim;
        N,m := f:-N,f:-m;
        sample::static := proc()
            B := f:-sample(args);
            confkde0(B);
            return B;
        end proc;
    end module;
end proc;

drawconf := proc(V,ord:=true)
    if(type(V,'Matrix')) then
        m,n := Dimension(V);
        return display([seq(drawconf(V[i]),i=1..m)]);
    elif(type(V,'list')) then
        n := nops(V);
    elif(type(V,'Vector')) then
        n := Dimension(V);
    end if;
    n := n/2;
    if(ord) then
        cl := [blue,red,green,brown,seq(black,i=5..n)];
    else
        cl := [seq(black,i=1..n)];
    end if;
    ans := [];
    for i from 1 to n do
        p := [V[2*i-1],V[2*i]];
        for j from i+1 to n do
            q := [V[2*j-1],V[2*j]];
            r := sqrt((p[1]-q[1])^2+(p[2]-q[2])^2);
            if(r<1.3) then
                ans := [op(ans),line(p,q,linestyle=dash)];
            end if;
        end do;
    end do;
    ans := [op(ans),seq(point([V[2*i-1],V[2*i]],symbol=solidcircle,color=cl[i]),i=1..n)];
    return display(ans,view=[-2..2,-2..2]);
end proc;

tikzconf := proc(V,ord:=true)
    s := "\\begin{tikzpicture}\n";
    if(type(V,'Matrix')) then
        m,n := Dimension(V);
        for i from 1 to m do
            s := cat(s,tikzconf0(convert(V[i],'list'),ord));
        end do;
        return s;
    elif(type(V,'list')) then
        n := nops(V);
    elif(type(V,'Vector')) then
        n := Dimension(V);
    end if;
    s := cat(s,tikzconf0(convert(V,'list'),ord));
    s := cat(s,"\\end{tikzpicture}\n");
    printf(s);
end proc;

tikzconf0 := proc(xl,ord)
    n := nops(xl)/2;
    if(ord) then
        cl := ["blue","red","green","brown",seq("black",i=5..n)];
    else
        cl := [seq("black",i=1..n)];
    end if;
    s := "";
    for i from 1 to n do
        p := [xl[2*i-1],xl[2*i]];
        for j from i+1 to n do
            q := [xl[2*j-1],xl[2*j]];
            r := sqrt((p[1]-q[1])^2+(p[2]-q[2])^2);
            if(r<1.3) then
                s := cat(s,nprintf("\\draw[black,semithick,densely dashed](%f,%f)--(%f,%f);\n",xl[2*i-1],xl[2*i],xl[2*j-1],xl[2*j]));
            end if;
        end do;
    end do;
    for i from 1 to n do
        s := cat(s,nprintf(cat("\\filldraw[",cl[i],"] (%f,%f) circle (1.000000pt);\n"),xl[2*i-1],xl[2*i]));
    end do;
    return s;
end proc;

drawfiber := proc(B)
    N := Dimension(B)[1];
    ans := [];
    for i from 1 to N do
        p1 := [B[i,1],B[i,2]];
        p2 := [B[i,3],B[i,4]];
        p3 := [B[i,5],B[i,6]];
        p2 := p2-p1;
        p3 := p3-p1;
        p1 := p1-p1;
        r := sqrt(p2[1]^2+p2[2]^2);
        p2 := p2/r;
        p3 := p3/r;
        c,s := op(p2);
        p2 := [c*p2[1]+s*p2[2],-s*p2[1]+c*p2[2]];
        p3 := [c*p3[1]+s*p3[2],-s*p3[1]+c*p3[2]];
        ans := [op(ans),point(p1,symbol=solidcircle,symbolsize=4,color=blue)];
        ans := [op(ans),point(p2,symbol=solidcircle,symbolsize=4,color=red)];
        ans := [op(ans),point(p3,symbol=solidcircle,symbolsize=4,color=black)];
    end do;
    return display(ans,view=[-1..2,-2..2]);
end proc;

confpairs := proc(vv)
    n := numelems(vv);
    return seq([vv[2*i-1],vv[2*i]],i=1..n/2);
end proc;

confcent := proc(vv)
    p1,p2,p3 := confpairs(vv);
    p0 := (p1+p2+p3)/3;
    return [op(p1-p0),op(p2-p0),op(p3-p0)];
end proc;

stereomap := proc(p)
    x,y := op(p);
    return [2*x,2*y,1-x^2-y^2]/(1+x^2+y^2);
end proc;

hopfmap := proc(vv)
    vv1,vv2 := vv[[1,3,5]],vv[[2,4,6]];
    q1 := 1/sqrt(2.0)*[1,0,-1];
    q2 := 1/sqrt(6.0)*[1,-2,1];
    ww := [vecdot(vv1,q1),vecdot(vv2,q1),vecdot(vv1,q2),vecdot(vv2,q2)];
    r := vecnorm(ww);
    ww := ww/r;
    z1,z2 := ww[1]+ww[2]*I,ww[3]+ww[4]*I;
    if(true) then
        z := z1/z2;
        p := [Re(z),Im(z)];
        ans := stereomap(p);
    else
        z := z2/z1;
        p := [Re(z),Im(z)];
        ans := stereomap(p);
        ans[2] := -ans[2];
        ans[3] := -ans[3];
    end if;
    return r*ans;
end proc;

