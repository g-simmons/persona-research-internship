IndMaps := module()
option package;
export cordind,indcord,arrdim,allocarr,wordtab,cord,invord,gridord,numlabs,ordarr,imregion,arrvec;
local rangevec,fullrange;

    arrdim := proc(A)
        return seq(op(2,rng),rng=ArrayTools:-Dimensions(A));
    end proc;

    allocarr := proc()
        if(not type(procname,indexed)) then
            return allocarr[float[8]](args);
        end if;
        typ := op(procname);
        ans := [];
        for ml in args do
            ans := [op(ans),Array(seq(1..m,m=ml),datatype=typ)];
        end do;
        return op(ans);
    end proc;

    cordind := proc(kl,ml)
        l := nops(ml);
        ans := kl[1]-1;
        for j from 2 to l do
            ans := ans*ml[j]+(kl[j]-1);
        end do;
        return ans+1;
    end proc;

    numlabs := proc(E)
        if(nargs=2) then
            return args[2];
        elif(type(E,'Matrix')) then
            return Dimension(E)[1];
        else
            return numelems(E);
        end if;
    end proc;

    cordind1 := proc(E::Array(datatype=integer[4]),ml::Array(datatype=integer[4]),J::Array(datatype=integer[4]),N::integer[4],l::integer[4])
        for k from 1 to N do
            i := E[k,1]-1;
            for j from 2 to l do
                i := i*ml[j]+(E[k,j]-1);
            end do;
            J[k] := i+1;
        end do;
    end proc;

    cordind1 := Compiler:-Compile(cordind1);

    indcord := proc(k,ml)
        l := nops(ml);
        r := k-1;
        ans := [];
        for j from 1 to l do
            m := ml[l-j+1];
            r1 := r mod m;
            ans := [r1+1,op(ans)];
            r := (r-r1)/m;
        end do;
        return ans;
    end proc;

    indcord1 := proc(J::Array(datatype=integer[4]),ml::Array(datatype=integer[4]),E::Array(datatype=integer[4]),N::integer[4],l::integer[4])
        for k from 1 to N do
            i := J[k];
            r := i-1;
            for j from 1 to l do
                m := ml[l-j+1];
                r1 := r mod m;
                E[k,l-j+1] := r1+1;
                r := round(evalf(r-r1)/evalf(m));
            end do;
        end do;
    end proc;

    indcord1 := Compiler:-Compile(indcord1);

#invert the indices
    invord := proc(ord)
        N := numelems(ord);
        N1 := max(ord);
        ans := veci(N1);
        for i from 1 to N do
            ans[ord[i]] := i;
        end do;
        return ans;
    end proc;

    rangevec := proc()
        if(type(args[1],'Vector')) then
            return args[1];
        elif(type(args[1],'numeric')) then
            return veci([seq(i,i=1..args[1])]);
        elif(type(args[1],`..`)) then
            return rangevec([seq(i,i=args[1])]);
        else
            return veci(args);
        end if;
    end proc;

    fullrange := proc(J)
        if(nargs=0 or type(args[1],`..`) and nops(args[1])=0) then
            return true;
        else
            return false;
        end if;
    end proc;

    cord := proc(ml)
        argl := [ml];
        md := module()
        option object;
        export `?[]`,getdims,getelt,getelts,getelts1,getind,getinds,getinds1,`numelems`,`whattype`,N,l,getsize;
        local ModulePrint,ModuleApply,ml,ml1,getinds0,getelts0;
            ml := argl[1];
            l := nops(ml);
            N := convert(ml,`*`);
            ml1 := veci(ml);
            ModulePrint::static := proc()
                return nprintf("c-ordered indices, %d indices of dimension %d",N,l);
            end proc;
            ModuleApply::static := proc()
                return getind(args);
            end proc;
            getsize::static := proc()
                return N;
            end proc;
            `?[]`::static := proc()
                argl := args[2];
                if(type(argl[1],'numeric')) then
                    return getelt(op(argl));
                else
                    return getelts(op(argl));
                end if;
            end proc;
            getdims::static := proc()
                return op(ml);
            end proc;
            getind::static := proc(kl)
                return cordind(kl,ml);
            end proc;
            getinds::static := proc(E)
                if(nargs=0) then
                    return getinds0();
                end if;
                N1 := Dimension(E)[1];
                J := veci(N1);
                cordind1(E,ml1,J,N1,l);
                return J;
            end proc;
            getinds1::static := proc(E,J,N1:=Dimension(E)[1])
                cordind1(E,ml1,J,N1,l);
                return N1;
            end proc;
            getinds0::static := proc()
            option remember;
                return veci([seq(i,i=1..N)]);
            end proc;
            getelt::static := proc(k)
                return indcord(k,ml);
            end proc;
            getelts::static := proc(J)
                if(fullrange(args)) then
                    return getelts0();
                end if;
                J := rangevec(args);
                E := mati(Dimension(J),l);
                getelts1(J,E,args[2..nargs]);
                return E;
            end proc;
            getelts0::static := proc()
            option remember;
                E := allocla[integer[4]](N);
                J := getinds0();
                getelts1(J,E,N);
                return E;
            end proc;
            getelts1::static := proc(J,E,N1:=Dimension(J))
                indcord1(J,ml1,E,N1,l);
                return N1;
            end proc;
            `whattype`::static := proc()
                return 'Cord';
            end proc;
            `numelems`::static := proc()
                return N;
            end proc;
        end module;
        return md;
    end proc;

    gridord0 := proc(rng,ml)

    end proc;

    labgrid0 := proc(E::Array(datatype=integer[4]),rng::Array(datatype=float[8]),ml::Array(datatype=integer[4]),B::Array(datatype=float[8]),N::integer[4],l::integer[4])
        for k from 1 to N do
            for i from 1 to l do
                B[k,i] := rng[i,1]+(evalf(E[k,i])-.5)*(rng[i,2]-rng[i,1])/evalf(ml[i]);
            end do;
        end do;
    end proc;

    labgrid0 := Compiler:-Compile(labgrid0);

    gridlab0 := proc(B::Array(datatype=float[8]),rng::Array(datatype=float[8]),ml::Array(datatype=integer[4]),E::Array(datatype=integer[4]),N::integer[4],l::integer[4])
        for k from 1 to N do
            for i from 1 to l do
                E[k,i] := round(.5+ml[i]*(B[k,i]-rng[i,1])/(rng[i,2]-rng[i,1]));
            end do;
        end do;
    end proc;

    gridlab0 := Compiler:-Compile(gridlab0);

    gridord := proc(rng,ml)
        if(type(args[2],'numeric')) then
            M := args[2];
            t := min(seq((op(2,r)-op(1,r))/M,r=rng));
            ml1 := [seq(ceil((op(2,r)-op(1,r))/t),r=rng)];
            return gridord(rng,ml1);
        end if;
        argl := [args];
        md := module()
        option object;
        export A,rng,getrange,getlab,getlabs,getelt,getelts,getelts1,getind,getinds,getinds1,getpoint,getpoints,getdims,getsize,labord,`numelems`,`whattype`,`?[]`,N,l;
        local ModuleApply,ml,ml1,rng1,dyn,init,E0,getinds0,get;
            rng,ml := op(argl);
            labord := cord(ml);
            ModulePrint::static := proc()
                s := cat(seq("%dx",i=1..l-1),"%d");
                s := cat(s," grid to index map");
                return nprintf(s,op(ml));
            end proc;
            getsize::static := proc()
                return N;
            end proc;
            getrange::static := proc()
                return op(rng);
            end proc;
            getlab::static := proc(xl)
                return [seq(round(.5+ml[i]*(xl[i]-rng1[i,1])/(rng1[i,2]-rng1[i,1])),i=1..l)];
            end proc;
            getlabs::static := proc(B,N1:=Dimension(B)[1])
                E := allocla[integer[4]]([N1,l]);
                getlabs1(B,E,N1);
                return E;
            end proc;
            getlabs1::static := proc(B,E,N1:=Dimension(B)[1])
                allocif(N1);
                gridlab0(B,rng1,ml1,E,N1,l);
                return N1;
            end proc;
            getdims::static := proc()
                return op(ml);
            end proc;
            `?[]`::static := proc()
                return getelts(op(args[2]));
            end proc;
            ModuleApply::static := proc(B)
                if(type(B,'list')) then
                    return getind(args);
                else
                    return getinds(args);
                end if;
            end proc;
            getpoint::static := proc(kl)
                return [seq(rng1[i,1]+(rng1[i,2]-rng1[i,1])*(kl[i]-.5)/ml[i],i=1..l)];
            end proc;
            getelt::static := proc(i)
                return getpoint(labord:-getelt(i));
            end proc;
            getelts::static := proc()
                if(fullrange(args)) then
                    return getelts0();
                end if;
                J := rangevec(args);
                N1 := Dimension(J);
                B := matf(N1,l);
                getelts1(J,B,N1);
                return B;
            end proc;
            getelts0::static := proc()
            option remember;
                B := matf(N,l);
                J := getinds0();
                getelts1(J,B,N);
                return B;
            end proc;
            getelts1::static := proc(J,B,N1:=Dimension(J))
                allocif(N1);
                labord:-getelts1(J,E0,N1);
                labgrid0(E0,rng1,ml1,B,N1,l);
                return N1;
            end proc;
            getind::static := proc(xl)
                return labord:-getind(getlab(xl));
            end proc;
            getinds::static := proc(B)
                if(nargs=0) then
                    return getinds0();
                end if;
                J := allocla[integer[4]](Dimension(B)[1]);
                getinds1(B,J);
                return J;
            end proc;
            getinds0::static := proc()
                return labord:-getinds();
            end proc;
            getinds1::static := proc(B,J,N1:=Dimension(B)[1])
                allocif(N1);
                getlabs1(B,E0,N1);
                labord:-getinds1(E0,J,N1);
            end proc;
            allocif::static := proc(N1)
                if(dyn:-allocif(N1)) then
                    E0 := dyn:-getelts();
                end if;
            end proc;
            init::static := proc()
                N,l := convert(ml,`*`),nops(ml);
                ml1 := veci(ml);
                rng1 := matf([seq([op(r)],r=rng)]);
                dyn := dynla(integer[4](l));
                E0 := dyn:-getelts();
            end proc;
            `numelems`::static := proc()
                return getsize();
            end proc;
            init();
        end module;
    end proc;

    ordvec0 := proc(J::Array(datatype=integer[4]),vec::Array(datatype=float[8]),V::Array(datatype=float[8]),N::integer[4])
        for k from 1 to N do
            V[k] := vec[J[k]];
        end do;
    end proc;

    ordvec0 := Compiler:-Compile(ordvec0);

    ordvec1 := proc(J::Array(datatype=integer[4]),V::Array(datatype=float[8]),vec::Array(datatype=float[8]),N::integer[4])
        for k from 1 to N do
            vec[J[k]] := V[k];
        end do;
    end proc;

    ordvec1 := Compiler:-Compile(ordvec1);

    ordarr := proc(ord)
        if(type(ord,'list')) then
            return ordarr(cord(args[1]),args[2..nargs]);
        end if;
        argl := [ord];
        md := module()
        option object;
        export indord,vec,getval,getvals,getvals1,setval,setvals,getvec,setvec,`numelems`,`convert`,N,getsize;
        local J0,init,ModulePrint,dyn;
            ModulePrint::static := proc()
                s := "ordered array object";
                return nprintf(s);
            end proc;
            getsize::static := proc()
                return N;
            end proc;
            getval::static := proc(x)
                i := indord:-getind(x);
                return vec[i];
            end proc;
            getvals::static := proc(labs)
                getvals1(labs);
                return getvec(J0,N1);
            end proc;
            getvals1::static := proc(labs,N1:=numlabs(labs))
                allocif(N1);
                indord:-getinds1(labs,J0,N1);
                V := allocla[float[8]](N1);
                getvec1(J0,V);
                return V;
            end proc;
            setval::static := proc(x,a)
                i := indord:-getind(x);
                V[i] := a;
            end proc;
            setvals::static := proc(E,V,N1:=Dimension(V))
                allocif(N1);
                indord:-getinds1(E,J0,N1);
                setvec(J0,V,N1);
            end proc;
            getvec::static := proc()
                if(nargs=0) then
                    return vec;
                end if;
                J := rangevec(args,N);
                N1 := Dimension(J);
                V := allocla[float[8]](N1);
                getvec1(J,V,N1);
                return V;
            end proc;
            getvec1::static := proc(J,V,N1:=Dimension(J))
                ordvec0(J,vec,V,N1);
                return N1;
            end proc;
            setvec::static := proc(J,V,N1:=Dimension(J))
                ordvec1(J,V,vec,N1);
                return;
            end proc;
            `numelems`::static := proc()
                return N;
            end proc;
            allocif::static := proc(N1)
                if(dyn:-allocif(N1)) then
                    J0 := dyn:-getelts();
                end if;
            end proc;
            init::static := proc()
                indord := args[1];
                N := indord:-getsize();
                vec := allocla[float[8]](N);
                dyn := dynla(integer[4]);
                J0 := dyn:-getelts();
            end proc;
            init(op(argl));
        end module;
    end proc;

    tomat0 := proc(vec::Array(datatype=float[8]),A::Array(datatype=float[8]),mode::integer[4],m::integer[4],n::integer[4])
        for i from 1 to m do
            for j from 1 to n do
                k := n*(i-1)+j;
                if(mode=0) then
                    A[i,j] := vec[k];
                else
                    A[n-j+1,i] := vec[k];
                end if;
            end do;
        end do;
    end proc;

    tomat0 := Compiler:-Compile(tomat0);

    imregion := proc(rng,ml)
        if(nargs>2) then
            md := imregion(args[2..3]);
            md:-setmap(args[1]);
            return md;
        end if;
        gord := gridord(args);
        argl := [gord];
        md := module()
        option object;
        export rng,arr,tomat,getdims,setmap,getvec,setvec,getval,getvals,setval,setvals,vec,N,`numelems`,l,gord,`whattype`,getrange,`convert`,draw,defcol;
        local ModuleApply,ModulePrint,V0;
            gord := op(argl);
            rng := [gord:-getrange()];
            l := nops(rng);
            arr := ordarr(gord);
            vec := arr:-vec;
            N := gord:-getsize();
            V0 := allocla[float[8]](l);
            defcol := 'viridis';
            ModuleApply::static := proc(labs)
                if(type(labs,'list')) then
                    return getval(args);
                else
                    return getvals(args);
                end if;
            end proc;
            ModulePrint::static := proc()
                s := "%dx%d image region";
                return nprintf(s,getdims());
            end proc;
            `whattype`::static := proc()
                return 'ImRegion';
            end proc;
            `numelems`::static := proc()
                return N;
            end proc;
            `convert`::static := proc()
                if(args[2]='Matrix') then
                    return tomat();
                end if;
            end proc;
            getrange::static := gord:-getrange;
            getdims::static := gord:-getdims;
            setvec::static := arr:-setvec;
            getvec::static := arr:-getvec;
            getval::static := arr:-getval;
            getvals::static := arr:-getvals;
            setval::static := arr:-setval;
            setvals::static := arr:-setvals;
            draw::static := proc(col:=defcol)
                A := tomat(true);
                return drawmat(A,col);
            end proc;
            tomat::static := proc(mode:=true)
                if(l<>2) then
                    error;
                end if;
                m,n := getdims();
                if(mode) then
                    A := matf(n,m);
                else
                    A := matf(m,n);
                end if;
                tomat0(vec,A,ddel(mode),m,n);
                return A;
            end proc;
            setmap::static := proc(f)
            local V;
                try
                    X := gord:-getelts();
                    for i from 1 to N do
                        getrow1(X,i,V0,l);
                        vec[i] := f(V0);
                    end do;
                    return;
                catch: "invalid input";
                    return setmap(V->f(V[1],V[2]));
                end try;
            end proc;
        end module;
        return md;
    end proc;

    arrvec0	:= proc(ml,dtype)
        d := nops(ml);
        code := "proc(arr::Array(datatype=";
        code := cat(code,convert(dtype,'string'));
        code := cat(code,"),vec::Array(datatype=");
        code := cat(code,convert(dtype,'string'));
        code := cat(code,"))\n");
        code := cat(code,"k0 := 0;\n");
        for a from 1 to d do
        m := ml[a];
            code := cat(code,"for i",a," from 1 to ",m," do\n");
            code := cat(code,"k",a," := ",m,"*k",a-1,"+i",a,"-1;\n");
        end do;
        code := cat(code,"k := k",d,"+1;\n");
        code := cat(code,"vec[k] := arr[");
        code := cat(code,"i1");
        for a from 2 to d do
            code := cat(code,",i",a);
        end do;
        code := cat(code,"];\n");
        for a from 1 to d do
            code := cat(code,"end do;\n");
        end do;
        code := cat(code,"end proc;\n");
        return Compiler:-Compile(parse(code));
    end proc;

    arrvec1	:= proc(ml,dtype)
        d := nops(ml);
        code := "proc(vec::Array(datatype=";
        code := cat(code,convert(dtype,'string'));
        code := cat(code,"),arr::Array(datatype=");
        code := cat(code,convert(dtype,'string'));
        code := cat(code,"))\n");
        code := cat(code,"k0 := 0;\n");
        for a from 1 to d do
            m := ml[a];
            code := cat(code,"for i",a," from 1 to ",m," do\n");
            code := cat(code,"k",a," := ",m,"*k",a-1,"+i",a,"-1;\n");
        end do;
        code := cat(code,"k := k",d,"+1;\n");
        code := cat(code,"arr[");
        code := cat(code,"i1");
        for a from 2 to d do
            code := cat(code,",i",a);
        end do;
        code := cat(code,"] := vec[k];\n");
        for a from 1 to d do
        code := cat(code,"end do;\n");
        end do;
        code := cat(code,"end proc;\n");
        return Compiler:-Compile(parse(code));
    end proc;

    arrvec := proc(ml,dtype:=float[8])
        md := module()
        option object;
        export ml,N,dtype,tovec,toarr,arr2vec,vec2arr;
        local ModulePrint;
            ModulePrint::static := proc()
                return nprintf(cat(ml,"-dimensional array<->vector in c-order"));
            end proc;
            tovec::static := proc(arr)
                vec := Vector(N,datatype=dtype);
                arr2vec(arr,vec);
                return vec;
            end proc;
            toarr::static := proc(vec)
                arr := Array(seq(1..m,m=ml),datatype=dtype);
                vec2arr(vec,arr);
                return arr;
            end proc;
        end module;
        md:-arr2vec := arrvec0(ml,dtype);
        md:-vec2arr := arrvec1(ml,dtype);
        md:-ml := ml;
        md:-dtype := dtype;
        md:-N := convert(ml,`*`);
        return md;
    end proc;

end module;
