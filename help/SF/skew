`SF/text/skew` := TEXT(
`   `,
`FUNCTION:  skew - skew operation on symmetric functions`,
`   `,
`CALLING SEQUENCE:  skew(f,g);      skew(f,g,b1,b2);`,
`                   skew(f,g,scp);  skew(f,g,b1,b2,scp);`,
`   `,
`PARAMETERS:   f,g  = symmetric functions`,
`             b1,b2 = (optional) names of bases`,
`              scp  = (optional) a procedure that accepts partitions as input`,
`   `,
`SYNOPSIS:`,
`  Let < , > be a scalar product of symmetric functions in which the power`,
`  sums are orthogonal, and let 'scp' be a procedure such that scp(mu)`,
`  computes the squared norm of the power sum indexed by mu. The standard`,
`  scalar product is obtained by choosing scp=zee. See 'scalar' and 'zee'.`,
`   `,
`  For each symmetric function f, there is a linear operator Skew(f) on`,
`  symmetric functions that is adjoint (via < , >) to multiplication by f.`,
`  That is, <Skew(f)g,h>=<g,f*h> for all symmetric functions f, g, h.`,
`   `,
`  If f and g are symmetric functions and 'scp' is as described, then`,
`  skew(f,g,scp) returns Skew(f)g (relative to < , >). The output is`,
`  collected with respect to the power-sums and 'normal' is applied to`,
`  the coefficients.`,
`   `,
`  If the last argument 'scp' is omitted, then by default the adjoint is`,
`  computed relative to the standard scalar product. Hence skew(f,g) is`,
`  equivalent to skew(f,g,zee).`,
`   `,
`  If two additional arguments b1 and b2 are specified, then f and g`,
`  are assumed to be expressed solely in terms of the bases b1 and b2,`,
`  respectively. In particular, if (say) b1 is not one of the predefined`,
`  bases, this requires f to be linear in the members of b1.`,
`   `,
`  If lambda and mu are partitions, then the skew Schur function indexed by`,
`  the pair lambda/mu is  skew(s[mu],s[lambda]). However, it is generally`,
`  faster to compute skew Schur functions via the Jacobi-Trudi identity:`,
`  linalg[det](jt_matrix(lambda,mu)).`,
`   `,
`EXAMPLES:`,
`  skew(e3,s[4,2]);              yields                    0`,
`  f:=skew(p2,h6,p,h);`,
`  toh(f);                       yields                   h4`,
`  Zee:= mu -> zee(mu,0,t);`,
`  f:=skew(p2,s[4,2],Zee);`,
`  tos(f);                       yields       s[4]/(1-t^2) + s[2,2]/(1-t^2)`,
`   `,
`SEE ALSO:  jt_matrix, scalar, zee`,
NULL):

if `+`(0)=0 then # Maple V.4 or later
  print(INTERFACE_HELP(insert, topic=`SF/skew`,
  helpfile=HomeLib, text=`SF/text/skew`))
elif ceil(0)=0 then # Maple V.2 or V.3
  `help/SF/text/skew`:=`SF/text/skew`:
  save `help/SF/text/skew`, cat(HomeLib,`/help/SF/text/skew.m`);
fi:
