`SF/text/dual_basis` := TEXT(
`   `,
`FUNCTION:  dual_basis - add a dual basis to the set of known bases`,
`   `,
`CALLING SEQUENCE:  dual_basis(b,oldb);`,
`                   dual_basis(b,oldb,scp);`,
`   `,
`PARAMETERS:   b   = name of a new basis `,
`             oldb = name of a previously defined basis`,
`             scp  = (optional) a procedure that accepts partitions as input`,
`   `,
`SYNOPSIS:`,
`  Let < , > be a scalar product of symmetric functions in which the power`,
`  sums are orthogonal, and let 'scp' be a procedure such that scp(mu)`,
`  computes the squared norm of the power sum indexed by mu. The standard`,
`  scalar product is obtained by choosing scp=zee. See 'scalar' and 'zee'.`,
`   `,
`  Assuming < , > is non-degenerate, every basis B[.] of the space of`,
`  symmetric functions has a unique dual basis b[.] defined by the property`,
`  that <b[lambda],B[mu]> = 1 for lambda=mu, and = 0 otherwise.`,
`   `,
`  For example, relative to the standard scalar product, the monomial`,
`  symmetric functions m[.] are dual to the basis generated by the complete`,
`  homogeneous symmetric functions h1,h2,....`,
`   `,
`  If 'oldb' is the name of any previously defined symmetric function basis`,
`  (i.e., a member of the global variable ``SF/Bases``), and 'b' is a name that`,
`  has not been previously defined to be a symmetric function basis, then the`,
`  procedure call  dual_basis(b,oldb,scp)  will add 'b[]' to the list of`,
`  known bases, and define it to be the basis that is dual to 'oldb',`,
`  relative to the scalar product defined by 'scp'. The effects of this are:`,
`   `,
`  (1) All predefined conversion procedures for symmetric functions, such`,
`  as 'toe', 'top',... as well as procedures defined by previous calls to`,
`  'dual_basis' and 'add_basis', will now be able to process symmetric`,
`  function expressions that involve the new basis 'b'.`,
`   `,
`  (2) A new procedure, named to.b (i.e., the concatenation of "to" and b)`,
`  is defined. Its purpose is to convert symmetric functions into the newly`,
`  created b-basis. The possible calling sequences for this procedure are:`,
`   `,
`        to.b(f);   to.b(f,B);   to.b(f,parlist);   to.b(f,B,parlist);`,
`   `,
`  where: (i) f is a symmetric function, (ii) B is an optional name that`,
`  may be used to indicate that f is expressed solely in terms of the`,
`  basis B, and (iii) 'parlist' is an optional list of partitions that may`,
`  be used to specify that the coefficient of b[lambda] is nonzero only for`,
`  partitions lambda appearing in 'parlist'.`,
`   `,
`  If f is "sparse" with respect to 'b', specifying a partition list can`,
`  greatly improve the speed of the algorithm.`,
`   `,
`  The output is collected with respect to the elements of the basis 'b' and`,
`  'normal' is applied to the coefficients.`,
`   `,
`  An error condition is generated if 'b' is, or if 'oldb' is not, the name`,
`  of a previously defined basis. Otherwise, the result returned by a call`,
`  to 'dual_basis' is 'Okay'. If the last argument (the procedure defining`,
`  the scalar product) is omitted, the standard scalar product is assumed.`,
`   `,
`EXAMPLES:`,
`#Define the basis of monomial symmetric functions`,
`  dual_basis(m,h);`,
`  tom(s[2,2,1],s,dominate([2,2,1]));`,
`                             yields   m[2,2,1]+2*m[2,1,1,1]+5*m[1,1,1,1,1]`,
`  tos(m[2,2]+m[3,1],m);      yields      s[3,1]-2*s[2,1,1]+3*s[1,1,1,1]`,
`   `,
`  Zee:= mu -> zee(mu,0,t);`,
`  dual_basis(S,s,Zee);`,
`  toe(S[2,1]);               yields  (-t+t^2)*e1^3+(1-t^3)*e2*e1+(-1+t^3)*e3`,
`  toS(e2*e1*(1-t)^2*(1-t^2),e);`,
`                             yields       t*S[3]+(t+1)*S[2,1]+S[1,1,1]`,
`   `,
`SEE ALSO:  add_basis, scalar, zee`,
NULL):

if `+`(0)=0 then # Maple V.4 or later
  print(INTERFACE_HELP(insert, topic=`SF/dual_basis`,
  helpfile=HomeLib, text=`SF/text/dual_basis`))
elif ceil(0)=0 then # Maple V.2 or V.3
  `help/SF/text/dual_basis`:=`SF/text/dual_basis`:
  save `help/SF/text/dual_basis`, cat(HomeLib,`/help/SF/text/dual_basis.m`);
fi:
