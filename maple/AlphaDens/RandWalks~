RandWalks := module()
option package;
export rowsum,colsum,rownorm,colnorm,diag,specgraph,graphlap,randadj;

    rowsum := proc(C)
        m,n := Dimension(C);
        pi := Vector([seq(add(C[i,j],j=1..n),i=1..m)],datatype=float[8]);
        return pi;
    end proc;

    colsum := proc(C)
        m,n := Dimension(C);
        pi := Vector([seq(add(C[i,j],i=1..m),j=1..n)],datatype=float[8]);
        return Transpose(pi);
    end proc;

    rownorm := proc(C)
        pi := rowsum(C);
        P := DiagonalMatrix(pi,datatype=float[8])^(-1).C;
        if(nargs=2 and args[2]=true) then
            return P,pi;
        else
            return P;
        end if;
    end proc;

    colnorm := proc(C)
        pi := colsum(C);
        P := C.DiagonalMatrix(pi,datatype=float[8])^(-1);
        if(nargs=2 and args[2]=true) then
            return P,pi;
        else
            return P;
        end if;
    end proc;

#random weighted adjacency matrix
    randadj := proc(n)
        A := Matrix([seq([seq(randf(0,1),j=1..n)],i=1..n)],datatype=float[8]);
        for i from 1 to n do
            for j from i+1 to n do
            A[i,j] := A[j,i];
            end do;
        end do;
        for i from 1 to n do
            A[i,i] := 0.0;
        end do;
        return A;
    end proc;

    diag := proc(xl)
        return DiagonalMatrix(xl,datatype=float[8]);
    end proc;

#the symmetric form of the graph laplacian.
    graphlap := proc(A,rnorm)
        m := Dimension(A)[1];
        L := -A;
        for i from 1 to m do
            L[i,i] := L[i,i]-add(L[i,j],j=1..m);
        end do;
        if(nargs=2 and rnorm=true) then
            pi := rowsum(A);
            L := diag([seq(1/x,x=pi)]).L;
        end if;
        return L;
    end proc;

#laplacian operator, and spectral bases of a weighted adjacency matrix
#A, with allowable nonzero diagonal. if B1,B2 are the spectral and
#dual bases, and L is the laplacian, then we have B2.L.B1 is the
#diagonal matrix of eigenvalues. the first column of B1 is normalized
#to be all one, so that the first row of B2 is the steady state of the
#random walk.
    specgraph := proc(A)
    local x;
    uses LinAlg;
        md := module()
        option object;
        export A,P,pi,n,init,getadj,getwalk,getsteady,specbas,dualbas,geteigs,getdim,getlap,getsvd,lapmap;
        local ModulePrint;
            ModulePrint::static := proc()
                return nprintf("spectral basis of a symmetric random walk "
                               "on %d vertices",n);
            end proc;
            getadj::static := proc()
                return A;
            end proc;
            getwalk::static := proc()
                return P;
            end proc;
            getlap::static := proc(rnorm:=true)
            option remember;
                return graphlap(A,rnorm);
            end proc;
            getdim::static := proc()
                return n;
            end proc;
            getdegs::static := proc()
                return pi;
            end proc;
            getsteady::static := proc()
            option remember;
                return pi/convert(pi,`+`);
            end proc;
            getsvd::static := proc()
            option remember;
                D1 := diag([seq(1/sqrt(x),x=pi)]);
                D2 := diag([seq(sqrt(x),x=pi)]);
                C := D1.(diag(pi)+A).D1;
                B,La := SingularValues(C,output=['U','S']);
                B1,B2 := D1.B,Transpose(B).D2;
                c := B1[1,1];
                for i from 1 to n do
                    B1[i,1] := B1[i,1]/c;
                    B2[1,i] := B2[1,i]*c;
                end do;
                La := vecf([seq(max(0.0,2-x),x=La)]);
                La[1] := 0.0; #for rounding errors;
                return La,B1,B2;
            end proc;
            lapmap::static := proc(f)
                return B1.diag([seq(f(x),x=La)]).B2;
            end proc;
            geteigs::static := proc()
                return getsvd()[1];
            end proc;
            specbas::static := proc()
                return getsvd()[2];
            end proc;
            dualbas::static := proc()
                return getsvd()[3];
            end proc;
            init::static := proc()
                A := args[1];
                n := Dimension(A)[1];
                P := rownorm(A);
                pi := rowsum(A);
            end proc;
        end module;
        md:-init(A);
        return md;
    end proc;

end module;
